<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Network Diagram</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
        }

        svg {
            width: 100vw;
            height: 100vh;
            background-color: #ffffff;
        }

        .tooltip {
            position: absolute;
            text-align: center;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 4px;
            pointer-events: none;
            visibility: hidden;
            font-size: 12px;
        }

        text {
            font-family: Arial, sans-serif;
            font-size: 12px;
        }

        .root-node {
            font-weight: bold;
            font-size: 16px; 
            fill: black; 
        }

        .parent-node {
            font-weight: bold;
            font-size: 14px; 
            color: black;
        }
    
        .child-node {
            font-weight: normal;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <svg></svg> 
<!-- 
The <svg> element is the canvas where D3.js will render the graph. 
SVG (Scalable Vector Graphics) is resolution-independent, making it ideal for visualizations.
-->

<div class="tooltip" id="tooltip"></div> 
<!-- 
Tooltip element to display additional information about nodes on hover.
-->

<!-- Import D3.js library from the official CDN -->
<script src="https://d3js.org/d3.v6.min.js"></script>

<script>
    /***************************************************************
     * VARIABLE DECLARATIONS AND INITIAL SETUP
     ***************************************************************/

    // Root node for the visualization; this is the main point from which other nodes connect
    const rootNode = 'UPMIS';

    // Select the <svg> element and the tooltip element using D3.js
    const svg = d3.select("svg");
    const tooltip = d3.select("#tooltip");

    // Get the width and height of the window to use for SVG dimensions
    const width = window.innerWidth;
    const height = window.innerHeight;

    /**
     * Create a color scale for different node types. 
     * This assigns specific colors to categories of nodes (like Application, Technology, etc.)
     * 
     * D3 offers many scales you can explore:
     *  - d3.scaleOrdinal: For categorical data (used here)
     *  - d3.scaleLinear: For continuous numeric data
     *  - d3.scaleSequential: For gradients based on numeric values
     */
    const colorScale = d3.scaleOrdinal()
        .domain(['Application', 'Technology', 'People', 'Software', 'Server']) // Node categories
        .range(['#231f20', '#bc945b', '#458bca', '#3253a8', '#888a8d']); // Corresponding colors

    // Create a group <g> element where all the graph elements (nodes and links) will reside
    const g = svg.append("g");

    // A Map to store node colors by their ID for quick reference
    const nodeColorMap = new Map();

    // Declare the simulation outside to make it accessible across functions
    let simulation;

    /***************************************************************
     * FETCHING DATA FROM THE BACKEND
     ***************************************************************/

    /**
     * Fetch graph data from the backend API. 
     * This function is asynchronous to handle the fetch request and wait for the response.
     */
    async function fetchGraphData() {
        const response = await fetch("/", {
            headers: { "Accept": "application/json" } // Expecting JSON data from the server
        });

        // If the request fails, log an error and exit
        if (!response.ok) {
            console.error("Failed to fetch graph data:", response.statusText);
            return;
        }

        // Parse the response into JSON
        const graphData = await response.json();
        console.log("Fetched Data:", graphData); // Log the data to inspect its structure

        // Assign colors to the nodes
        assignColors(graphData);

        // Render the graph visualization
        renderGraph(graphData);
    }

    /***************************************************************
     * ASSIGNING COLORS TO NODES BASED ON THEIR TYPE
     ***************************************************************/

    /**
     * This function assigns colors to nodes using a color scale based on the node's type.
     * You can modify the color scale or add more categories dynamically.
     */
    function assignColors(data) {
        data.nodes.forEach(node => {
            if (node.id === rootNode) {
                nodeColorMap.set(node.id, '#231f20'); // Root node (UPMIS) is black
            } else {
                const color = colorScale(node.type); // Get color from scale based on type
                nodeColorMap.set(node.id, color);
            }
        });
    }

        /**
    * Helper function to check if a node is a parent node.
    * A node is considered a parent if it is the source of at least one link.
    *
    * @param {Object} node - The node object to check.
    * @param {Object} graphData - The entire graph data containing nodes and links.
    * @returns {boolean} - Returns true if the node is a parent; otherwise, false.
    */
    function isParentNode(node, graphData) {
        // A node is a parent if it is the source of at least one link
        return graphData.links.some(link => link.source.id === node.id);
    }

    /**
    * Renders the graph using D3.js by setting up nodes, links, and force simulation.
    * This function ensures that nodes and links are displayed correctly with appropriate
    * interactivity, such as dragging and tooltip handling.
    *
    * @param {Object} graphData - The graph data containing nodes and links.
    */
    function renderGraph(graphData) {
        /***************************************************************
        * CREATE A MAP TO REFERENCE NODE OBJECTS BY THEIR ID
        ***************************************************************/
        const nodeById = new Map(graphData.nodes.map(node => [node.id, node]));

        // Replace source and target IDs in links with actual node objects
        graphData.links.forEach(link => {
            link.source = nodeById.get(link.source); // Link's source node object
            link.target = nodeById.get(link.target); // Link's target node object
        });

        /***************************************************************
        * INITIALIZE THE FORCE SIMULATION
        * The simulation applies physics-like behavior to nodes, such as
        * repelling or attracting forces and centering the graph.
        ***************************************************************/
        simulation = d3.forceSimulation(graphData.nodes) // Initialize force simulation
            .force("link", d3.forceLink(graphData.links).distance(70)) // Control link length
            .force("charge", d3.forceManyBody().strength(-100)) // Repulsion between nodes
            .force("center", d3.forceCenter(width / 2, height / 2)) // Center the graph
            .on("tick", ticked); // On each tick, update the positions of nodes and links

        /***************************************************************
        * CREATE LINKS BETWEEN NODES
        * Links are represented as lines connecting nodes. We use conditional
        * coloring to match the link color with the child node type, if applicable.
        ***************************************************************/
        const link = g.append("g") // Append group element for links
            .selectAll("line") // Select all lines for links
            .data(graphData.links) // Bind link data to the elements
            .enter().append("line") // Append a line for each link
            .attr("stroke-width", 1) // Set the thickness of the link lines
            .attr("stroke", "#231f20"); // Set the line color to black

        /***************************************************************
        * CREATE NODES AND ASSIGN CSS CLASSES BASED ON TYPE
        * Each node consists of a circle and a text label. We use CSS classes
        * ('parent-node' or 'child-node') to style nodes dynamically.
        ***************************************************************/
        const node = g.append("g") // Append group element for nodes
            .selectAll("g") // Select all group elements for nodes
            .data(graphData.nodes) // Bind node data to the elements
            .enter().append("g") // Append a group for each node
            .call(d3.drag() // Enable dragging functionality
                .on("start", dragstarted) // Handle drag start event
                .on("drag", dragged) // Handle dragging event
                .on("end", dragended)); // Handle drag end event

        /***************************************************************
        * APPEND CIRCLES FOR NODES
        * Circles visually represent each node, and we fill them with colors
        * based on the node's ID. Tooltips are shown on hover.
        ***************************************************************/
        node.append("circle") // Append a circle for each node
            .attr("r", d => {
                if (d.id === rootNode) return 6; // Root node is the largest
                if (isParentNode(d, graphData)) return 5; // Parent nodes are bigger
                return 3; // Child nodes retain the default size
            })
            .attr("fill", d => nodeColorMap.get(d.id)) // Set circle color based on node ID
            .on("mouseover", (event, d) => showTooltip(event, d)) // Show tooltip on hover
            .on("mousemove", moveTooltip) // Move tooltip with mouse
            .on("mouseout", hideTooltip); // Hide tooltip when mouse leaves

        /***************************************************************
        * APPEND TEXT LABELS FOR NODES
        * Text labels display the node IDs. They are styled using CSS classes
        * to differentiate between parent and child nodes.
        ***************************************************************/
        // Append text labels for each node
        node.append("text")
        .attr("dx", 5) // Horizontal offset for text
        .attr("dy", 1) // Vertical alignment
        .text(d => d.id) // Display the node ID
        .attr("class", d => {
            // Assign 'root-node' if it's the root node, otherwise assign parent/child class
            if (d.id === rootNode) return 'root-node'; 
            return isParentNode(d, graphData) ? 'parent-node' : 'child-node';
        });

        /***************************************************************
        * SIMULATION TICK FUNCTION: UPDATE POSITIONS OF NODES AND LINKS
        * This function runs on every tick of the simulation, ensuring that
        * the positions of nodes and links are updated continuously.
        ***************************************************************/
        function ticked() {
            // Constrain node positions within the browser window boundaries
            node.attr("transform", d => {
                d.x = Math.max(5, Math.min(width - 5, d.x)); // Ensure x stays within [5, width - 5]
                d.y = Math.max(5, Math.min(height - 5, d.y)); // Ensure y stays within [5, height - 5]
                return `translate(${d.x},${d.y})`;
            });
        
            // Update the link positions
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
        }        
    }

    /***************************************************************
    * TOOLTIP FUNCTIONS TO DISPLAY NODE INFORMATION
    ***************************************************************/

    // Display the tooltip when hovering over a node
    function showTooltip(event, d) {
        // Use the node's description if available
        const description = d.description ? `${d.description}` : 'No description available';
        tooltip.style("visibility", "visible").text(description);
    }    

    // Move the tooltip with the mouse
    function moveTooltip(event) {
        tooltip.style("top", (event.pageY + 10) + "px")
            .style("left", (event.pageX + 10) + "px");
    }

    // Hide the tooltip when the mouse leaves the node
    function hideTooltip() {
        tooltip.style("visibility", "hidden");
    }

    /***************************************************************
    * DRAG FUNCTIONS TO ENABLE INTERACTIVE NODE MOVEMENT
    ***************************************************************/

    // Handle the start of a drag event
    function dragstarted(event) {
        if (!event.active) simulation.alphaTarget(0.3).restart(); // Restart simulation
        event.subject.fx = event.subject.x; // Fix x position
        event.subject.fy = event.subject.y; // Fix y position
    }

    // Update the node's position during dragging
    function dragged(event) {
        event.subject.fx = event.x; // Set new x position
        event.subject.fy = event.y; // Set new y position
    }

    // Release the node's position at the end of the drag
    function dragended(event) {
        if (!event.active) simulation.alphaTarget(0); // Stop the simulation after drag
        event.subject.fx = null; // Release fixed x position, allowing it to move freely
        event.subject.fy = null; // Release fixed y position, restoring natural movement
    }


    /***************************************************************
     * INITIALIZING AND FETCHING GRAPH DATA ON PAGE LOAD
     ***************************************************************/

    /**
     * Call `fetchGraphData` when the page loads to initialize the graph.
     * This will retrieve the graph data from the backend and render it in the SVG element.
     */
    fetchGraphData(); // Start fetching and rendering the graph
    </script>
</body>
</html>
